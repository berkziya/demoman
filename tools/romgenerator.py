import os
import math
import argparse
from PIL import Image

# --- Core Functions ---


def get_rom_depth_from_png(mif_file_path: str) -> int | None:
    """
    Calculates ROM depth (number of words) from a PNG image.
    Assumes the PNG has the same base name as the MIF file and is in the same directory.
    Each pixel is considered one word.

    Args:
        mif_file_path: The path to the MIF file.

    Returns:
        The number of words (pixels), or None if an error occurs.
    """
    if not mif_file_path.lower().endswith(".mif"):
        print(f"Error: Expected a .mif file path, got {mif_file_path}")
        return None

    base_path, _ = os.path.splitext(mif_file_path)  # Handles .mif, .MIF etc.
    png_file_path = base_path + ".png"

    if not os.path.exists(png_file_path):
        print(
            f"Error: PNG file not found at {png_file_path} (expected for MIF file {mif_file_path})"
        )
        return None

    try:
        with Image.open(png_file_path) as img:
            width, height = img.size
            return width * height
    except Exception as e:
        print(f"Error reading PNG file {png_file_path}: {e}")
        return None


def generate_rom_files(
    rom_name: str,
    addr_width: int,
    data_width: int,
    num_words: int,
    mif_file_path_for_verilog: str,  # Path to the .mif file to be embedded in Verilog
    device_family: str,
    quartus_version_full: str,
    quartus_version_short: str,
    output_dir: str,
) -> bool:
    """
    Generates the .v, _bb.v, and .qip files for an Altera Quartus 1-port ROM.

    Args:
        rom_name: Base name for the ROM module and output files.
        addr_width: Width of the address bus.
        data_width: Width of the data output bus.
        num_words: Number of words in the ROM.
        mif_file_path_for_verilog: The path to the .mif file as it should appear for the primary INIT_FILE.
        device_family: Target Altera FPGA device family.
        quartus_version_full: Full Quartus version string for comments.
        quartus_version_short: Short Quartus version string for the .qip file.
        output_dir: Directory to save the generated files.

    Returns:
        True if file generation was successful, False otherwise.
    """
    # Input validation
    if not all(
        [
            rom_name,
            mif_file_path_for_verilog,
            device_family,
            quartus_version_full,
            quartus_version_short,
            output_dir,
        ]
    ):
        print(
            "Error: Missing one or more required string arguments for ROM generation."
        )
        return False
    if addr_width < 0:
        print(f"Error: Address width ({addr_width}) cannot be negative.")
        return False
    if data_width < 1:
        print(f"Error: Data width ({data_width}) must be at least 1.")
        return False
    if num_words < 1:
        print(f"Error: Number of words ({num_words}) must be at least 1.")
        return False

    expected_addr_width = 0
    if num_words == 1:
        expected_addr_width = 1
    elif num_words > 1:
        expected_addr_width = math.ceil(math.log2(num_words))

    if addr_width < expected_addr_width:
        print(
            f"Error: Address width ({addr_width}) is insufficient for {num_words} words. Needs {expected_addr_width}."
        )
        return False

    addr_bus_range = f"[{addr_width - 1}:0]" if addr_width > 0 else ""
    data_bus_range = f"[{data_width - 1}:0]"

    cnx_addr_width = max(1, addr_width)
    cnx_data_width = max(1, data_width)
    addr_msb = max(0, addr_width - 1)
    data_msb = max(0, data_width - 1)

    os.makedirs(output_dir, exist_ok=True)

    # --- Generate .v file ---
    v_file_path = os.path.join(output_dir, f"{rom_name}.v")
    v_file_content = f"""// {rom_name}.v
// megafunction wizard: %ROM: 1-PORT%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altsyncram

// ============================================================
// File Name: {rom_name}.v
// Megafunction Name(s):
//      altsyncram
//
// Simulation Library Files(s):
//      altera_mf
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// {quartus_version_full}
// ************************************************************

//Copyright (C) 2025  Altera Corporation. All rights reserved.
//Your use of Altera Corporation's design tools, logic functions
//and other software and tools, and any partner logic
//functions, and any output files from any of the foregoing
//(including device programming or simulation files), and any
//associated documentation or information are expressly subject
//to the terms and conditions of the Altera Program License
//Subscription Agreement, the Altera Quartus Prime License Agreement,
//the Altera IP License Agreement, or other applicable license
//agreement, including, without limitation, that your use is for
//the sole purpose of programming logic devices manufactured by
//Altera and sold by Altera or its authorized distributors.  Please
//refer to the Altera Software License Subscription Agreements
//on the Quartus Prime software download page.

// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module {rom_name} (
  address,
  clock,
  q);

  input {addr_bus_range}  address;
  input   clock;
  output {data_bus_range}  q;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
  tri1    clock;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

  wire {data_bus_range} sub_wire0;
  wire {data_bus_range} q = sub_wire0[{data_msb}:0];

  altsyncram  altsyncram_component (
        .address_a (address),
        .clock0 (clock),
        .q_a (sub_wire0),
        .aclr0 (1'b0),
        .aclr1 (1'b0),
        .address_b (1'b1),
        .addressstall_a (1'b0),
        .addressstall_b (1'b0),
        .byteena_a (1'b1),
        .byteena_b (1'b1),
        .clock1 (1'b1),
        .clocken0 (1'b1),
        .clocken1 (1'b1),
        .clocken2 (1'b1),
        .clocken3 (1'b1),
        .data_a ({{{data_width}{{1'b1}}}}),
        .data_b (1'b1),
        .eccstatus (),
        .q_b (),
        .rden_a (1'b1),
        .rden_b (1'b1),
        .wren_a (1'b0),
        .wren_b (1'b0));
  defparam
    altsyncram_component.address_aclr_a = "NONE",
    altsyncram_component.clock_enable_input_a = "BYPASS",
    altsyncram_component.clock_enable_output_a = "BYPASS",
    altsyncram_component.init_file = "{mif_file_path_for_verilog}",
    altsyncram_component.intended_device_family = "{device_family}",
    altsyncram_component.lpm_hint = "ENABLE_RUNTIME_MOD=NO",
    altsyncram_component.lpm_type = "altsyncram",
    altsyncram_component.numwords_a = {num_words},
    altsyncram_component.operation_mode = "ROM",
    altsyncram_component.outdata_aclr_a = "NONE",
    altsyncram_component.outdata_reg_a = "CLOCK0",
    altsyncram_component.widthad_a = {addr_width},
    altsyncram_component.width_a = {data_width},
    altsyncram_component.width_byteena_a = 1;

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: ADDRESSSTALL_A NUMERIC "0"
// Retrieval info: PRIVATE: AclrAddr NUMERIC "0"
// Retrieval info: PRIVATE: AclrByte NUMERIC "0"
// Retrieval info: PRIVATE: AclrOutput NUMERIC "0"
// Retrieval info: PRIVATE: BYTE_ENABLE NUMERIC "0"
// Retrieval info: PRIVATE: BYTE_SIZE NUMERIC "{data_width}"
// Retrieval info: PRIVATE: BlankMemory NUMERIC "0"
// Retrieval info: PRIVATE: CLOCK_ENABLE_INPUT_A NUMERIC "0"
// Retrieval info: PRIVATE: CLOCK_ENABLE_OUTPUT_A NUMERIC "0"
// Retrieval info: PRIVATE: Clken NUMERIC "0"
// Retrieval info: PRIVATE: IMPLEMENT_IN_LES NUMERIC "0"
// Retrieval info: PRIVATE: INIT_FILE_LAYOUT STRING "PORT_A"
// Retrieval info: PRIVATE: INIT_TO_SIM_X NUMERIC "0"
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "{device_family}"
// Retrieval info: PRIVATE: JTAG_ENABLED NUMERIC "0"
// Retrieval info: PRIVATE: JTAG_ID STRING "NONE"
// Retrieval info: PRIVATE: MAXIMUM_DEPTH NUMERIC "0"
// Retrieval info: PRIVATE: MIFfilename STRING "{mif_file_path_for_verilog}"
// Retrieval info: PRIVATE: NUMWORDS_A NUMERIC "{num_words}"
// Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC "0"
// Retrieval info: PRIVATE: RegAddr NUMERIC "1"
// Retrieval info: PRIVATE: RegOutput NUMERIC "1"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
// Retrieval info: PRIVATE: SingleClock NUMERIC "1"
// Retrieval info: PRIVATE: UseDQRAM NUMERIC "0"
// Retrieval info: PRIVATE: WidthAddr NUMERIC "{addr_width}"
// Retrieval info: PRIVATE: WidthData NUMERIC "{data_width}"
// Retrieval info: PRIVATE: rden NUMERIC "0"
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: CONSTANT: ADDRESS_ACLR_A STRING "NONE"
// Retrieval info: CONSTANT: CLOCK_ENABLE_INPUT_A STRING "BYPASS"
// Retrieval info: CONSTANT: CLOCK_ENABLE_OUTPUT_A STRING "BYPASS"
// Retrieval info: CONSTANT: INIT_FILE STRING "{mif_file_path_for_verilog}"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "{device_family}"
// Retrieval info: CONSTANT: LPM_HINT STRING "ENABLE_RUNTIME_MOD=NO"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altsyncram"
// Retrieval info: CONSTANT: NUMWORDS_A NUMERIC "{num_words}"
// Retrieval info: CONSTANT: OPERATION_MODE STRING "ROM"
// Retrieval info: CONSTANT: OUTDATA_ACLR_A STRING "NONE"
// Retrieval info: CONSTANT: OUTDATA_REG_A STRING "CLOCK0"
// Retrieval info: CONSTANT: WIDTHAD_A NUMERIC "{addr_width}"
// Retrieval info: CONSTANT: WIDTH_A NUMERIC "{data_width}"
// Retrieval info: CONSTANT: WIDTH_BYTEENA_A NUMERIC "1"
// Retrieval info: USED_PORT: address 0 0 {cnx_addr_width} 0 INPUT NODEFVAL "address[{addr_msb}..0]"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT VCC "clock"
// Retrieval info: USED_PORT: q 0 0 {cnx_data_width} 0 OUTPUT NODEFVAL "q[{data_msb}..0]"
// Retrieval info: CONNECT: @address_a 0 0 {cnx_addr_width} 0 address 0 0 {cnx_addr_width} 0
// Retrieval info: CONNECT: @clock0 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: q 0 0 {cnx_data_width} 0 @q_a 0 0 {cnx_data_width} 0
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.inc FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.cmp FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.bsf FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}_inst.v FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}_bb.v TRUE
// Retrieval info: LIB_FILE: altera_mf
"""
    try:
        with open(v_file_path, "w") as f:
            f.write(v_file_content)
    except IOError as e:
        print(f"Error writing .v file {v_file_path}: {e}")
        return False

    # --- Generate _bb.v file ---
    bb_v_file_path = os.path.join(output_dir, f"{rom_name}_bb.v")
    bb_v_file_content = f"""// {rom_name}_bb.v
// megafunction wizard: %ROM: 1-PORT%VBB%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altsyncram

// ============================================================
// File Name: {rom_name}.v
// Megafunction Name(s):
//      altsyncram
//
// Simulation Library Files(s):
//      altera_mf
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// {quartus_version_full}
// ************************************************************

//Copyright (C) 2025 Altera Corporation. All rights reserved.
//Your use of Altera Corporation's design tools, logic functions
//and other software and tools, and any partner logic
//functions, and any output files from any of the foregoing
//(including device programming or simulation files), and any
//associated documentation or information are expressly subject
//to the terms and conditions of the Altera Program License
//Subscription Agreement, the Altera Quartus Prime License Agreement,
//the Altera IP License Agreement, or other applicable license
//agreement, including, without limitation, that your use is for
//the sole purpose of programming logic devices manufactured by
//Altera and sold by Altera or its authorized distributors.  Please
//refer to the Altera Software License Subscription Agreements
//on the Quartus Prime software download page.

module {rom_name} (
  address,
  clock,
  q);

  input {addr_bus_range}  address;
  input   clock;
  output {data_bus_range}  q;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
  tri1    clock;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: ADDRESSSTALL_A NUMERIC "0"
// Retrieval info: PRIVATE: AclrAddr NUMERIC "0"
// Retrieval info: PRIVATE: AclrByte NUMERIC "0"
// Retrieval info: PRIVATE: AclrOutput NUMERIC "0"
// Retrieval info: PRIVATE: BYTE_ENABLE NUMERIC "0"
// Retrieval info: PRIVATE: BYTE_SIZE NUMERIC "{data_width}"
// Retrieval info: PRIVATE: BlankMemory NUMERIC "0"
// Retrieval info: PRIVATE: CLOCK_ENABLE_INPUT_A NUMERIC "0"
// Retrieval info: PRIVATE: CLOCK_ENABLE_OUTPUT_A NUMERIC "0"
// Retrieval info: PRIVATE: Clken NUMERIC "0"
// Retrieval info: PRIVATE: IMPLEMENT_IN_LES NUMERIC "0"
// Retrieval info: PRIVATE: INIT_FILE_LAYOUT STRING "PORT_A"
// Retrieval info: PRIVATE: INIT_TO_SIM_X NUMERIC "0"
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "{device_family}"
// Retrieval info: PRIVATE: JTAG_ENABLED NUMERIC "0"
// Retrieval info: PRIVATE: JTAG_ID STRING "NONE"
// Retrieval info: PRIVATE: MAXIMUM_DEPTH NUMERIC "0"
// Retrieval info: PRIVATE: MIFfilename STRING "{mif_file_path_for_verilog}"
// Retrieval info: PRIVATE: NUMWORDS_A NUMERIC "{num_words}"
// Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC "0"
// Retrieval info: PRIVATE: RegAddr NUMERIC "1"
// Retrieval info: PRIVATE: RegOutput NUMERIC "1"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
// Retrieval info: PRIVATE: SingleClock NUMERIC "1"
// Retrieval info: PRIVATE: UseDQRAM NUMERIC "0"
// Retrieval info: PRIVATE: WidthAddr NUMERIC "{addr_width}"
// Retrieval info: PRIVATE: WidthData NUMERIC "{data_width}"
// Retrieval info: PRIVATE: rden NUMERIC "0"
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: CONSTANT: ADDRESS_ACLR_A STRING "NONE"
// Retrieval info: CONSTANT: CLOCK_ENABLE_INPUT_A STRING "BYPASS"
// Retrieval info: CONSTANT: CLOCK_ENABLE_OUTPUT_A STRING "BYPASS"
// Retrieval info: CONSTANT: INIT_FILE STRING "{mif_file_path_for_verilog}"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "{device_family}"
// Retrieval info: CONSTANT: LPM_HINT STRING "ENABLE_RUNTIME_MOD=NO"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altsyncram"
// Retrieval info: CONSTANT: NUMWORDS_A NUMERIC "{num_words}"
// Retrieval info: CONSTANT: OPERATION_MODE STRING "ROM"
// Retrieval info: CONSTANT: OUTDATA_ACLR_A STRING "NONE"
// Retrieval info: CONSTANT: OUTDATA_REG_A STRING "CLOCK0"
// Retrieval info: CONSTANT: WIDTHAD_A NUMERIC "{addr_width}"
// Retrieval info: CONSTANT: WIDTH_A NUMERIC "{data_width}"
// Retrieval info: CONSTANT: WIDTH_BYTEENA_A NUMERIC "1"
// Retrieval info: USED_PORT: address 0 0 {cnx_addr_width} 0 INPUT NODEFVAL "address[{addr_msb}..0]"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT VCC "clock"
// Retrieval info: USED_PORT: q 0 0 {cnx_data_width} 0 OUTPUT NODEFVAL "q[{data_msb}..0]"
// Retrieval info: CONNECT: @address_a 0 0 {cnx_addr_width} 0 address 0 0 {cnx_addr_width} 0
// Retrieval info: CONNECT: @clock0 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: q 0 0 {cnx_data_width} 0 @q_a 0 0 {cnx_data_width} 0
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.inc FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.cmp FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}.bsf FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}_inst.v FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL {rom_name}_bb.v TRUE
// Retrieval info: LIB_FILE: altera_mf
"""
    try:
        with open(bb_v_file_path, "w") as f:
            f.write(bb_v_file_content)
    except IOError as e:
        print(f"Error writing _bb.v file {bb_v_file_path}: {e}")
        return False

    # --- Generate .qip file ---
    qip_file_path = os.path.join(output_dir, f"{rom_name}.qip")
    qip_file_content = f"""set_global_assignment -name IP_TOOL_NAME "ROM: 1-PORT"
set_global_assignment -name IP_TOOL_VERSION "{quartus_version_short}"
set_global_assignment -name IP_GENERATED_DEVICE_FAMILY "{{{device_family}}}"
set_global_assignment -name VERILOG_FILE [file join $::quartus(qip_path) "{rom_name}.v"]
set_global_assignment -name MISC_FILE [file join $::quartus(qip_path) "{rom_name}_bb.v"]
"""
    try:
        with open(qip_file_path, "w") as f:
            f.write(qip_file_content)
    except IOError as e:
        print(f"Error writing .qip file {qip_file_path}: {e}")
        return False

    print(
        f"Successfully generated ROM files in '{output_dir}': {rom_name}.v, {rom_name}_bb.v, {rom_name}.qip"
    )
    return True


def main():
    parser = argparse.ArgumentParser(
        description="Generate Quartus 1-Port ROM IP files from a MIF file and its associated PNG."
    )
    parser.add_argument(
        "mif_file",
        help="Path to the input .mif file. A .png file with the same base name must exist in the same directory to determine ROM depth.",
    )
    parser.add_argument(
        "-o",
        "--output-dir",
        help="Directory to save the generated IP files. Defaults to the directory of the input .mif file.",
    )

    args = parser.parse_args()

    mif_file_arg = args.mif_file

    if not mif_file_arg.lower().endswith(".mif"):
        print(f"Error: Input file must be a .mif file. Provided: {mif_file_arg}")
        return

    # Determine output directory
    if args.output_dir:
        output_directory = args.output_dir
    else:
        output_directory = os.path.dirname(mif_file_arg)
        if not output_directory:
            output_directory = "."

    # --- ROM Parameters (some are fixed/configurable here) ---
    rom_data_width = 4  # Fixed at 4 bits per pixel/word

    # Update these to match your Quartus environment
    fpga_device_family = "Cyclone V"
    quartus_version_full_str = "24.1std.0 Build 1077 03/04/2025 SC Lite Edition"
    quartus_version_short_str = "24.1"

    # Derive rom_name from the MIF filename
    base_mif_filename = os.path.basename(mif_file_arg)
    rom_module_name, _ = os.path.splitext(base_mif_filename)

    # Get ROM depth from the associated PNG file
    calculated_num_words = get_rom_depth_from_png(mif_file_arg)

    if calculated_num_words is None or calculated_num_words < 1:
        if calculated_num_words == 0:
            print(
                f"Error: PNG associated with {mif_file_arg} indicates zero depth. Cannot generate ROM."
            )
        else:
            print(
                f"Error: Could not determine ROM depth from PNG for {mif_file_arg}. Aborting."
            )
        return

    if calculated_num_words == 1:
        rom_addr_width = 1
    else:
        rom_addr_width = math.ceil(math.log2(calculated_num_words))

    print(f"  Module Name: {rom_module_name}")
    print(f"  MIF File (for INIT_FILE): {mif_file_arg}")
    print(f"  Output Directory: {output_directory}")
    print(f"  Derived Depth (NumWords): {calculated_num_words}")
    print(f"  Calculated Address Width: {rom_addr_width}")
    print(f"  Data Width: {rom_data_width} (fixed)")
    print(f"  Device Family: {fpga_device_family}")

    success = generate_rom_files(
        rom_name=rom_module_name,
        addr_width=rom_addr_width,
        data_width=rom_data_width,
        num_words=calculated_num_words,
        mif_file_path_for_verilog=mif_file_arg,
        device_family=fpga_device_family,
        quartus_version_full=quartus_version_full_str,
        quartus_version_short=quartus_version_short_str,
        output_dir=output_directory,
    )

    if not success:
        print(f"Failed to generate ROM IP files for {rom_module_name}.")


if __name__ == "__main__":
    main()
